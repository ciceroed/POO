@startuml class-diagram-reviewed

skinparam ClassAttributeIconSize 0
skinparam linetype ortho

' ================= Lógica do Jogo (Model) =================

Enum GameState {
    PLAYER_TURN
    ENEMY_TURN
    PLAYER_VICTORY
    PLAYER_DEFEAT
}

class Game {
    - _player: Character
    - _mobs: vector<unique_ptr<Character>>
    - _currentState: GameState
    + getPlayerViewData(): CharacterViewData
    + getPlayerHandData(): vector<CardViewData>
    + getMobsData(): vector<CharacterViewData>
    + getMobHandData(mobId: int): vector<CardViewData>
    + getGameState(): GameState
    + startPlayerTurn(): void
    + startMobsTurn(): void
    + processNextMobAction(mobId: int): optional<CardViewData>
    + playCard(cardId: int, targetId: int, sourceId: int): void
    + cleanupDeadMobs(): void
    + checkForGameOver(): void
    - findCharacterById(characterId: int): Character*
}

class Character {
    - _id: int
    - _name: string
    - _health: int
    - _maxHealth: int
    - _mana: int
    - _maxMana: int
    - _hand: Hand
    ' Sugestão: Character possui o Deck
    - _deck: unique_ptr<Deck>
    - _spritePath: QString
    ' Membros estáticos são sublinhados
    - {static} _nextId: int
    + getHealth(): int
    + getMana(): int
    + getCharacterId(): int
    + getCharacterName(): string
    + getHandData(): vector<CardViewData>
    ' Sugestão: playCard em Character delega para um método playCard na Hand
    + playCard(cardId: int, target: Character&): void
    + spendMana(manaSpent: int): void
    + takeDamage(damage: int): void
    + buyNewCard(): void
    + cardRequiresTarget(cardId: int): bool
}

class Hand {
    - _cards: vector<unique_ptr<Card>>
    - _maxCards: const size_t
    + addCard(card: unique_ptr<Card>): void
    ' Sugestão: Refatorado para um método que centraliza a lógica
    + playCard(cardId: int, source: Character&, target: Character&): bool
    + getCardsData(): vector<CardViewData>
    + cardRequiresTarget(cardId: int): bool
}

class Deck {
    ' CRÍTICO: Usar unique_ptr para gerenciar a memória
    - _cards: vector<unique_ptr<Card>>
    + draw(): unique_ptr<Card>
    + addCard(card: unique_ptr<Card>): void
    + shuffle(): void
}

class Card {
    - _id: int
    - _manaCost: int
    - _title: string
    - _description: string
    ' Composição é mais preciso aqui
    - _effect: unique_ptr<ICardEffect>
    - _spritePath: QString
    - {static} _nextId: int
    + getCardId(): int
    + getManaCost(): int
    + getTitle(): string
    + getSpritePath(): QString
    + cardEffect(source: Character&, target: Character&): void
    + requiresTarget(): bool
}

interface ICardEffect <<Strategy>> {
    + {abstract} applyEffect(source: Character&, target: Character&): void
    + {abstract} requiresTarget(): bool
}

class AttackEffect {
    - _damageAmount: int
    + applyEffect(source: Character&, target: Character&): void
    + requiresTarget(): bool
}

' ================= Interface Gráfica (View) =================

class MainWindow {
    - _game: Game
    - _view: GameView*
    - _scene: QGraphicsScene*
    - _selectedCardId: int
    - _currentEnemyIndex: int
    - _statusTextItem: QGraphicsTextItem*
    - _endTurnButton: EndTurnButton*
    - _playerSprite: CharacterGraphic*
    - _mobSprites: QList<CharacterGraphic*>
    - _handCardSprites: QList<CardGraphic*>
    # resizeEvent(event: QResizeEvent*): void
    - updateLayout(): void
    - syncSceneWithGameState(): void
    - showTemporaryCard(cardData: const CardViewData&, durationMs: int): void
    <<slot>>
    + onCardClicked(cardId: int): void
    + onCharacterClicked(targetId: int): void
    + onEndTurnButtonClicked(): void
    + processNextEnemyAction(): void
}
class GameView {
    - _backgroundPixmap: QPixmap
    # drawBackground(painter: QPainter*, rect: const QRectF&): void
}
class GraphicItem {
    # _pixmap: QPixmap
    # _isHovered: bool
    # hoverEnterEvent(event: QGraphicsSceneHoverEvent*): void
    # hoverLeaveEvent(event: QGraphicsSceneHoverEvent*): void
    # mousePressEvent(event: QGraphicsSceneMouseEvent*): void
    + {abstract} paint(painter: QPainter*, option: const QStyleOptionGraphicsItem*, widget: QWidget*): void
    + {abstract} boundingRect(): QRectF
}
class CharacterGraphic {
    - _id: int
    - _currentHealth: int
    - _maxHealth: int
    <<signal>>
    + characterClicked(id: int): void
    + getCharacterId(): int
}

class CardGraphic {
    - _id: int
    <<signal>>
    + cardClicked(cardId: int): void
}
class EndTurnButton {
    <<signal>>
    + clicked(): void
}

' ================= Relacionamentos =================
' --- Relações de Posse (Composição) ---
MainWindow "1" *-- "1" Game
MainWindow "1" *-- "1" GameView
Character "1" *-- "1" Hand
Character "1" *-- "1" Deck
Hand "1" *-- "0..*" Card
Deck "1" *-- "0..*" Card
Card "1" *-- "1" ICardEffect

' --- Relações de Associação ---
Game "1" -- "1" Character : player >
Game "1" -- "0..*" Character : mobs >
Game ..> GameState : uses

MainWindow ..> CharacterGraphic : creates & manages
MainWindow ..> CardGraphic : creates & manages
MainWindow ..> EndTurnButton : creates & manages

' --- Relações de Herança/Implementação ---
CharacterGraphic ..|> GraphicItem
CardGraphic ..|> GraphicItem
EndTurnButton ..|> GraphicItem
AttackEffect ..|> ICardEffect
@enduml